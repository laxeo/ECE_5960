<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>ECE 5960 LAB 5</title>
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version1)-->
        <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="#page-top">
                <span class="d-block d-lg-none">Tongqing Zhang</span>
                
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="index.html">MainPage</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab1.html">LAB 1</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab2.html">LAB 2</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab3.html">LAB 3</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab4.html">LAB 4</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab5">LAB 5</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab6.html">LAB 6</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab7.html">LAB 7</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab8.html">LAB 8</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab9.html">LAB 9</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab10.html">LAB 10</a></li>
                    <li class="nav-item"><a class="nav-link" href="lab11.html">LAB 11</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <section class="resume-section" id="lab5">
                <div class="resume-section-content">
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-4"><h2 class="mb-2">LAB 5 - Open Loop Control</h2>
                    <div class="flex-shrink-0"><span class="text-primary2" >Feb 24<sup>th</sup>, 2022</span></div>
                    </div>
                    
                    <div class="flex-grow-1">
                        <h3 class="mb-1">Wiring</h3>
                        <div class="subheading mb-2">Connection Diagram</div>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/IMG_0120.jpg" alt="dia" title="dia" /></div>
                        <p>
                            First, I solder AIN1 to BIN1, AIN2 to BIN2, AOUT1 to BOUT1, AOUT2 to BOUT2 for both motor drivers using wires.
                            <br>
                            Second, I solder AOUT1 and AOUT2 of one motor driver to one dc motor and the same for the other.
                            <br>
                            Third, I solder pins on AIN1 and AIN2 for both motor drivers so that they can connect to pins on Artemis Board using wires.
                            <br>
                            Fourth, I solder the VIN and GND pins of the two motor drivers together so that I can use only one wire to power them together.
                            <br>
                            Finally, I will choose pin A0, A1, A2, A3 on Artemis Board to control the two motor drivers because these pins can generate
                            analog signals which are what we need.
                        </p>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/motors.jpg" alt="motors" title="motors" /></div>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/pykpl3wh1b0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                    </div>
                    
                    <div class="flex-grow-1">
                        <h3 class="mb-1">Performance Testing</h3>
                        <div class="subheading mb-2">Single motor driver</div>
                        <p>
                            First, I connect AIN1 and AIN2 of one motor driver to pin A0 and A1 of Artemis Board which is powered by a 850mAh battery,
                            and use the code below to control the motor driver. I set the duty cycle to be 255 which means the duty cycle is 100%, to find the working voltage range of the motor driver.
                            <br>
                            Second, I connect the VIN and GND to a power supply.
                            <br>
                            Finally, I adjust the voltage of the power supply from 0 to 5V to see the working current of the motor driver.
                        </p>
<pre><code>       void setup() {
            //activate the pins
            pinMode(A0, OUTPUT);
            pinMode(A1, OUTPUT);
            }
            
            void loop() {
            //send signals to motor drivers
            analogWrite(A0, 255);
            analogWrite(A1, 0);
            }</code></pre>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/xhdlNF-hlJQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <p>
                            I adjust the votage from 0V to 5V and I find that we need a lower limit of about 2.55V to generate current for motor driver and
                            about 2.7V to make the wheels spin, which coincides with the lowest operating voltage recorded in the documentation. And the minimum working current to make the wheel turn is about 0.35A. 
                            Then as I increase the voltage, the current also slowly rises, ranging from 0.35A to 0.5A. Under the rated working voltage of 3.7V, the rated working current is about 0.4A.
                        </p>

                        <div class="subheading mb-2">Analog PWM control</div>
                        <p>
                            From the documentation, the duty cycle should be set ranging from 0 to 255 which means 0~100% of a cycle.
                            Firstly, I set the duty cycle to be 255 which means 100% of a cycle. And from the video below we can know that the Artemis Board is generating
                            a constant high level signal to the motor driver and the frequency is 0Hz.
                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/i2QaBWXoGZA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <p>
                            Then I tired some other values of duty cycle and use a multimeter to measure rms. From the video below we can know that the analog signals generated by 
                            the Artemis Board have a frequency of about 182Hz and the rms match the calculation of the duty cycle.
                            <br>
                            Duty cycle: 30 ; Val: 11.72% ~ 30/255;
                            <br>
                            Duty cycle: 100 ; Val: 39.09% ~ 100/255;
                            <br>
                            So from the data above we know how the motor drivers work:
                            <br>
                            Since we are using dc motors, it can only receive two commands: turn and not turn, but cannot control the speed and its voltage.
                            <br>
                            So we need to generate a analog signal to the motor driver to control the spinning speed. We can set a duty cycle 'dc' which corresponds to a percentage.
                            This means that in one cycle, the proportion of high level signal is 'dc', which also means the wheel spinning time is 'dc' in one cycle. 
                            So when the frequency of the signal is high enough and the period is short enough, we can control the speed of motors very smoothly.

                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/iM3bkZ-rjdc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

                        <div class="subheading mb-2">Spin directions</div>
                        <p>
                            I change the direction of rotation of the motor by reversing the signal sent to the motor driver. Below are demo videos for the two motor drivers and motors.
                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/tk-wgxq36Sk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/MfNIsVlmfbA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

                        <div class="subheading mb-2">Lower limit to start on the ground</div>
                        <p>
                            I first put the car on a table and only activate one motor dirver once to measure the lower limit of duty cycle to make the car start.
                            <br>
                            From the demo videos for the two motor drivers, I find that the lower limit of duty cycle to make the car start is about 95 for one and 65 for the other,
                            which means that the two motors differ in their output power. However, this lower limit is also related to the battery voltage and power.
                            The more powerful the battery, the lower the lower limit.
                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/on5sMTA93Ys" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/_FNGMgDT3aU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

                        <div class="subheading mb-2">Go straight line</div>
                        <p>
                            From the test above we can know that the output power of the two motors is different under the same signal. But when the two motor drivers are connected together with the battery at the same time, their gap on output power is not as large as the previous experiment.
                            I do find the motor on the left is a little bit stronger than the one on the right. When I set the duty cycle to be 65 for the left one and 67 for the right one, the car move along a fairly straight line.
                            The calibration factor is about 65/67 = 0.97. Below is the demo video.
                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/r334CX56QrA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

                        <div class="subheading mb-2">Open Loop</div>
                        <p>
                            I design a loop for the car to make it go straight for a while and then turn around. So the car will move forth and back in a short distance.
                            The turning period should be related to the power of the battery and it is hard to decide.
                            So in subsequent labs, we still need to use the sensors to determine the rotation time to ensure the correct rotation angle.
                            <br>Below is the demo video.
                        </p>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/SVNwbbZqSO0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <pre><code>        #define fac 65.0/67.0;

        void setup() {
        //right
        pinMode(A0, OUTPUT);
        pinMode(A1, OUTPUT);
        //left
        pinMode(A2, OUTPUT);
        pinMode(A3, OUTPUT);
        }

        void loop() {
            analogWrite(A0, 67);
            analogWrite(A1, 0);
            analogWrite(A2, 0);
            analogWrite(A3, 65);
            delay(2000);
            analogWrite(A0, 255);
            analogWrite(A1, 0);
            analogWrite(A2, 255*fac);
            analogWrite(A3, 0);
            delay(200);
        } </code></pre>
                    </div>

                    <div class="flex-grow-1">
                        <h3 class="mb-1">5960 Tasks</h3>
                        <div class="subheading mb-2">Frequency Analysis</div>
                        <p>
                            From the video above we know that the frequency of analog signals generated by the Artemis Board is about 182Hz when the duty cycle is lower than 255.
                            And it also can go up to about 183Hz when I reverse the output signals, but it's still relatively stable.
                            <br>
                            Since we adjust the speed of motors by changing the duty cycle, theoretically, the shorter the cycle, the smoother the signals and the better the motors move.
                            <br>
                            But it takes time for Artemis Board to pull the signal high and low, which is called 'rising edge' and 'falling edge', and the period should be
                            much larger than the time of 'rising edge' and 'falling edge' so that they can be ignored.
                        </p>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/period.jpg" alt="period" title="period" /></div>
                        <p>
                            It can be seen from the waveform diagram of the oscilloscope that the rising and falling edges are almost a vertical line, so the period is
                            large enough to ignore the time to pull signal high and low. But if we can make the period as small as possible (which means make the frequency as large as possible)
                            while keeping it much larger than
                            the time of 'rising edge' and 'falling edge', then we will be able to control the speed of the car more smoothly.
                        </p>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/waveform.jpeg" alt="waveform" title="waveform" /></div>
                        
                        <div class="subheading mb-2">Ramp Up and Down</div>
                        <p>
                            I design a program to make the car speed up slowly to maximum for a while and then speed down quickly to avoid hitting the wall,
                            and use notify function to receive the dc value sent by Artemis Board in the meantime.
                        </p>
                        <p>In loop function</p>
                        <pre><code>        while (central.connected()) {

            if(state==0 && dc+15<=255) dc += 15;
            else if(dc-51>=0) dc -= 51;

            if(dc==255){
                state = 1;
                delay(300);
            }            
            
            straight();
            get_val();}</code></pre>
                        <p>Subfunctions:</p>
                        <pre><code>        void straight(){
            analogWrite(A0, dc);
            analogWrite(A1, 0);
            analogWrite(A2, 0);
            analogWrite(A3, dc);
            }

        void get_val(){
            tx_float_value = dc;
            tx_characteristic_float.writeValue(tx_float_value);
            }</code></pre>
                        <p>Notify function:</p>
                        <div class="mb-2" align="center"><img width="100%"  src="images/lab5/notify.png" alt="notify" title="notify" /></div>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/JxiQCmu0htE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <p>
                            To get the speed of the car:
                            <br>
                            Firstly, I hook up all the sensors on the car and connect them to the Artemis Board and activate one ToF at the front of the car to get the distance from the wall.
                            <br>
                            Secondly, I design a program which will make the car speed up slowly to maximum and keep running until receiving 'stop' command.
                            When the Artemis Board is connected to the computer via bluetooth, the car will first wait for 10s and then start.
                            <br>
                            Thirdly, I activate a notify function in Jupyter Lab to receive data read by ToF so that I can then calculate the maximum speed of the car.
                        </p>
                        <pre><code>        int t_0 = millis();
        // While central is connected
        
        while (central.connected()) {

            if(millis()-t_0>10000 dc+15<=255) dc += 15;       
            
            straight();
            get_tof();}</code></pre>
                        <p>Subfunctions:
                        </p>
                        <pre><code>        void get_tof()
        {
            distanceSensor.startRanging(); //Write configuration bytes to initiate measurement
            while (!distanceSensor.checkForDataReady())
            {
            delay(1);
            }
            int distance = distanceSensor.getDistance(); //Get the result of the measurement from the sensor
            distanceSensor.clearInterrupt();
            distanceSensor.stopRanging();
        
            Serial.println(distance);
        
            
            tx_estring_value.clear();
            tx_estring_value.append("[");
            tx_estring_value.append((float)millis());
            tx_estring_value.append(", ");
            tx_estring_value.append(distance);
            tx_estring_value.append("]");
            tx_characteristic_string.writeValue(tx_estring_value.c_str());
        }</code></pre>
                        <p>
                            Notify function:
                        </p>
                        <div class="mb-2" align="center"><img width="100%"  src="images/lab5/jupyterlab.png" alt="jupyterlab" title="jupyterlab" /></div>
                        <div align="center"><iframe width="640" height="360" src="https://www.youtube.com/embed/ZHN1z9gilC4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
                        <p>
                            Having collected the data from Jupyter Lab, I eliminated the invalid data and calculated the maximum running speed of the car from the valid data.
                            <br>
                            From the diagram below we can know that the maximum speed of the car is about 3.65m/s.
                        </p>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/rawdata.png" alt="rawdata" title="rawdata" /></div>
                        <div class="mb-2" align="center"><img width="85%"  src="images/lab5/validdata.png" alt="validdata" title="validdata" /></div>

                    </div>

                    

        


                    
            </section>
            <hr class="m-0" />
           
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
